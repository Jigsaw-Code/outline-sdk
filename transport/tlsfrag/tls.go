// Copyright 2023 Jigsaw Operations LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tlsfrag

import (
	"encoding/binary"
)

// This file contains helper functions and constants for TLS Client Hello message.

type recordType byte
type tlsVersion uint16
type tlsRecordHeader []byte

// TLS record layout from [RFC 8446]:
//
//	+-------------+ 0
//	| RecordType  |
//	+-------------+ 1
//	|  Protocol   |
//	|  Version    |
//	+-------------+ 3
//	|   Record    |
//	|   Length    |
//	+-------------+ 5
//	|   Message   |
//	|    Data     |
//	|     ...     |
//	+-------------+ Message Length + 5
//
//	RecordType := invalid(0) | handshake(22) | application_data(23) | ...
//	LegacyRecordVersion := 0x0301 ("TLS 1.0") | 0x0302 ("TLS 1.1") | 0x0303 ("TLS 1.2")
//	0 < Message Length (of handshake)        ≤ 2^14
//	0 ≤ Message Length (of application_data) ≤ 2^14
//
// [RFC 8446]: https://datatracker.ietf.org/doc/html/rfc8446#section-5.1
const (
	recordHeaderLen     = 5
	maxRecordPayloadLen = 1 << 14

	recordTypeHandshake recordType = 22

	versionTLS10 tlsVersion = 0x0301
	versionTLS11 tlsVersion = 0x0302
	versionTLS12 tlsVersion = 0x0303
	versionTLS13 tlsVersion = 0x0304
)

// tlsRecordHeaderFromRawBytes creates a new tlsRecordHeader from raw. This function will panic if len(raw) < 5.
func tlsRecordHeaderFromRawBytes(raw []byte) tlsRecordHeader {
	_ = raw[recordHeaderLen-1] // early panic on invalid data
	return tlsRecordHeader(raw[:recordHeaderLen])
}

// Type gets the TLS record type from the TLS header h[0]. This function will panic if len(h) < 1.
func (h tlsRecordHeader) Type() recordType {
	return recordType(h[0])
}

// LegacyVersion gets the TLS version from the TLS header h[1:3]. This function will panic if len(h) < 3.
func (h tlsRecordHeader) LegacyVersion() tlsVersion {
	return tlsVersion(binary.BigEndian.Uint16(h[1:3]))
}

// PayloadLen gets the TLS record payload length from the TLS header h[3:5]. This function will panic if len(h) < 5.
func (h tlsRecordHeader) PayloadLen() uint16 {
	return binary.BigEndian.Uint16(h[3:5])
}

// SetPayloadLen puts the TLS record payload len to the TLS header h[3:5]. This function will panic if len(h) < 5.
func (h tlsRecordHeader) SetPayloadLen(len uint16) {
	binary.BigEndian.PutUint16(h[3:5], len)
}

// isValidTLSVersion determines whether ver is a valid TLS version according to RFC:
//
//	"""
//	legacy_record_version:
//	MUST be set to 0x0303 for all records generated by a TLS 1.3 implementation other than an initial ClientHello,
//	where it MAY also be 0x0301 for compatibility purposes. This field is deprecated and MUST be ignored for all
//	purposes. Previous versions of TLS would use other values in this field under some circumstances.
//	"""
func isValidTLSVersion(ver tlsVersion) bool {
	return ver == versionTLS10 || ver == versionTLS11 || ver == versionTLS12 || ver == versionTLS13
}

// isValidPayloadLenForHandshake checks whether 0 < len ≤ 2^14.
func isValidPayloadLenForHandshake(len uint16) bool {
	return 0 < len && len <= maxRecordPayloadLen
}
