// Copyright 2023 Jigsaw Operations LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tlsfrag

import (
	"encoding/binary"
)

// This file contains helper functions and constants for TLS Client Hello message.

type recordType uint8
type tlsVersion uint16

// TLS record layout from [RFC 8446]:
//
//	+-------------+ 0
//	| RecordType  |
//	+-------------+ 1
//	|  Protocol   |
//	|  Version    |
//	+-------------+ 3
//	|   Record    |
//	|   Length    |
//	+-------------+ 5
//	|   Message   |
//	|    Data     |
//	|     ...     |
//	+-------------+ Message Length + 5
//
//	RecordType := invalid(0) | handshake(22) | application_data(23) | ...
//	Protocol Version (deprecated) := 0x0301 ("TLS 1.0") | 0x0303 ("TLS 1.2" & "TLS 1.3") | 0x0302 ("TLS 1.1")
//	0 < Message Length (of handshake)        ≤ 2^14
//	0 ≤ Message Length (of application_data) ≤ 2^14
//
// [RFC 8446]: https://datatracker.ietf.org/doc/html/rfc8446#section-5.1
const (
	tlsRecordWithTypeSize          = 1 // the minimum size that contains record type
	tlsRecordWithVersionHeaderSize = 3 // the minimum size that contains protocol version

	recordHeaderLen = 5
	maxMsgLen       = 1 << 14

	recordTypeHandshake recordType = 22

	versionTLS10 tlsVersion = 0x0301
	versionTLS11 tlsVersion = 0x0302
	versionTLS12 tlsVersion = 0x0303
	versionTLS13 tlsVersion = 0x0304
)

// getRecordType gets the TLS record type from the TLS header hdr[0]. This function will panic if len(hdr) < 1.
func getRecordType(hdr []byte) recordType {
	return recordType(hdr[0])
}

// putRecordType puts the TLS record type to the TLS header hdr[0]. This function will panic if len(hdr) < 1.
func putRecordType(hdr []byte, typ recordType) {
	hdr[0] = byte(typ)
}

// getTLSVersion gets the TLS version from the TLS header hdr[1:3]. This function will panic if len(hdr) < 3.
func getTLSVersion(hdr []byte) tlsVersion {
	return tlsVersion(binary.BigEndian.Uint16(hdr[1:]))
}

// putTLSVersion puts the TLS version to the TLS header hdr[1:3]. This function will panic if len(hdr) < 3.
func putTLSVersion(hdr []byte, ver tlsVersion) {
	binary.BigEndian.PutUint16(hdr[1:], uint16(ver))
}

// getMsgLen gets the TLS message length from the TLS header hdr[3:5]. This function will panic if len(hdr) < 5.
func getMsgLen(hdr []byte) uint16 {
	return binary.BigEndian.Uint16(hdr[3:])
}

// putMsgLen puts the TLS message length to the TLS header hdr[3:5]. This function will panic if len(hdr) < 5.
func putMsgLen(hdr []byte, len uint16) {
	binary.BigEndian.PutUint16(hdr[3:], len)
}

// isValidTLSProtocolVersion determines whether ver is a valid TLS version according to RFC:
//
//	"""
//	legacy_record_version:
//	MUST be set to 0x0303 for all records generated by a TLS 1.3 implementation other than an initial ClientHello,
//	where it MAY also be 0x0301 for compatibility purposes. This field is deprecated and MUST be ignored for all
//	purposes. Previous versions of TLS would use other values in this field under some circumstances.
//	"""
func isValidTLSVersion(ver tlsVersion) bool {
	return ver == versionTLS10 || ver == versionTLS11 || ver == versionTLS12 || ver == versionTLS13
}

// isValidRecordLenForHandshake checks whether 0 < len ≤ 2^14.
func isValidMsgLenForHandshake(len uint16) bool {
	return 0 < len && len <= maxMsgLen
}

// This function will panic if len(hdr) < 5.
func putTLSClientHelloHeader(hdr []byte, recordLen uint16) {
	_ = hdr[recordHeaderLen-1] // bounds check to guarantee safety of writes below
	putRecordType(hdr, recordTypeHandshake)
	putTLSVersion(hdr, versionTLS10)
	putMsgLen(hdr, recordLen)
}
